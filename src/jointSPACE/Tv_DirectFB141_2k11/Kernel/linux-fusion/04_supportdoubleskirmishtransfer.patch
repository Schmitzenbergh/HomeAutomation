commit d5b24d40d5c54ab56dcea90c9d18534530330335
Author: Niels Roest <niels@directfb.org>
Date:   Fri Jan 8 16:38:48 2010 +0100

    skirmish: add transfer2 to support double transfer of skirmishes
    
    problem arises when a call is made, which in turn calls yet another
    process - this requires the skirmishes to be transferred twice.
    
    This is not a final solution, since it does not allow 3 or more transfers.

diff --git a/linux/drivers/char/fusion/skirmish.c b/linux/drivers/char/fusion/skirmish.c
index f1f48f9..e845880 100644
--- a/linux/drivers/char/fusion/skirmish.c
+++ b/linux/drivers/char/fusion/skirmish.c
@@ -53,6 +53,11 @@ struct __FUSION_FusionSkirmish {
 	int transfer_from_pid;
 	int transfer_count;
 
+	FusionID transfer2_to;
+	FusionID transfer2_from;
+	int transfer2_from_pid;
+	int transfer2_count;
+
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
 	int pre_acquis[MAX_PRE_ACQUISITIONS];
 
@@ -245,11 +250,13 @@ int fusion_skirmish_prevail(FusionDev * dev, int id, int fusion_id)
 
 	up(&dev->skirmish.lock);
 
-	while (skirmish->lock_pid || (skirmish->transfer_to != 0 &&
-				      fusionee_dispatcher_pid(dev,
-							      skirmish->
-							      transfer_to) !=
-				      current->pid)) {
+	while (   skirmish->lock_pid 
+	       || (    (skirmish->transfer2_to == 0)
+	            &&  skirmish->transfer_to 
+	            && (fusionee_dispatcher_pid(dev, skirmish->transfer_to) != current->pid))
+	       || (     skirmish->transfer2_to
+	            && (fusionee_dispatcher_pid(dev, skirmish->transfer2_to) != current->pid)) )
+	{
 		ret = fusion_skirmish_wait(skirmish, NULL);
 		if (ret)
 			return ret;
@@ -283,11 +290,13 @@ int fusion_skirmish_swoop(FusionDev * dev, int id, int fusion_id)
 
 	dev->stat.skirmish_prevail_swoop++;
 
-	if (skirmish->lock_fid || (skirmish->transfer_to != 0 &&
-				   fusionee_dispatcher_pid(dev,
-							   skirmish->
-							   transfer_to) !=
-				   current->pid)) {
+	if (   skirmish->lock_fid 
+	    || (    (skirmish->transfer2_to == 0)
+	         &&  skirmish->transfer_to
+	         && (fusionee_dispatcher_pid(dev, skirmish->transfer_to) != current->pid))
+	    || (     skirmish->transfer2_to
+	         && (fusionee_dispatcher_pid(dev, skirmish->transfer2_to) != current->pid)) )
+	{
 		if (skirmish->lock_pid == current->pid) {
 			skirmish->lock_count++;
 			skirmish->lock_total++;
@@ -614,11 +623,28 @@ void fusion_skirmish_dismiss_all(FusionDev * dev, int fusion_id)
 			wake_up_interruptible_all(&skirmish->entry.wait);
 		}
 
+		if (skirmish->transfer2_from == fusion_id) {
+			skirmish->transfer2_to       = 0;
+			skirmish->transfer2_from     = 0;
+			skirmish->transfer2_from_pid = 0;
+			skirmish->transfer2_count    = 0;
+
+			wake_up_interruptible_all(&skirmish->entry.wait);
+		}
+
 		if (skirmish->transfer_from == fusion_id) {
-			skirmish->transfer_to       = 0;
-			skirmish->transfer_from     = 0;
-			skirmish->transfer_from_pid = 0;
-			skirmish->transfer_count    = 0;
+			/* we want no holes in the transfer stack */
+			skirmish->transfer_to       = skirmish->transfer2_to;
+			skirmish->transfer_from     = skirmish->transfer2_from;
+			skirmish->transfer_from_pid = skirmish->transfer2_from_pid;
+			skirmish->transfer_count    = skirmish->transfer2_count;
+
+			if (skirmish->transfer2_to) {
+				skirmish->transfer2_to       = 0;
+				skirmish->transfer2_from     = 0;
+				skirmish->transfer2_from_pid = 0;
+				skirmish->transfer2_count    = 0;
+			}
 
 			wake_up_interruptible_all(&skirmish->entry.wait);
 		}
@@ -650,11 +676,28 @@ void fusion_skirmish_dismiss_all_from_pid(FusionDev * dev, int pid)
 			wake_up_interruptible_all(&skirmish->entry.wait);
 		}
 
+		if (skirmish->transfer2_from_pid == pid) {
+			skirmish->transfer2_to       = 0;
+			skirmish->transfer2_from     = 0;
+			skirmish->transfer2_from_pid = 0;
+			skirmish->transfer2_count    = 0;
+
+			wake_up_interruptible_all(&skirmish->entry.wait);
+		}
+
 		if (skirmish->transfer_from_pid == pid) {
-			skirmish->transfer_to       = 0;
-			skirmish->transfer_from     = 0;
-			skirmish->transfer_from_pid = 0;
-			skirmish->transfer_count    = 0;
+			/* we want no holes in the transfer stack */
+			skirmish->transfer_to       = skirmish->transfer2_to;
+			skirmish->transfer_from     = skirmish->transfer2_from;
+			skirmish->transfer_from_pid = skirmish->transfer2_from_pid;
+			skirmish->transfer_count    = skirmish->transfer2_count;
+
+			if (skirmish->transfer2_to) {
+				skirmish->transfer2_to       = 0;
+				skirmish->transfer2_from     = 0;
+				skirmish->transfer2_from_pid = 0;
+				skirmish->transfer2_count    = 0;
+			}
 
 			wake_up_interruptible_all(&skirmish->entry.wait);
 		}
@@ -678,7 +721,8 @@ fusion_skirmish_transfer_all(FusionDev * dev,
 
 		down(&skirmish->entry.lock);
 
-		if ( (skirmish->lock_pid == from_pid) && (skirmish->transfer_to == 0) ) {
+		if (skirmish->lock_pid == from_pid) {
+		  if (skirmish->transfer_to == 0) {
 			FUSION_ASSERT(skirmish->transfer_from == 0);
 			FUSION_ASSERT(skirmish->transfer_from_pid == 0);
 			FUSION_ASSERT(skirmish->transfer_count == 0);
@@ -694,6 +738,23 @@ fusion_skirmish_transfer_all(FusionDev * dev,
 			skirmish->lock_count = 0;
 
 			wake_up_interruptible_all(&skirmish->entry.wait);
+		  } else if (skirmish->transfer2_to == 0) {
+			FUSION_ASSERT(skirmish->transfer2_from == 0);
+			FUSION_ASSERT(skirmish->transfer2_from_pid == 0);
+			FUSION_ASSERT(skirmish->transfer2_count == 0);
+			FUSION_ASSERT(skirmish->lock_count > 0);
+
+			skirmish->transfer2_to       = to;
+			skirmish->transfer2_from     = from;
+			skirmish->transfer2_from_pid = from_pid;
+			skirmish->transfer2_count    = skirmish->lock_count;
+
+			skirmish->lock_fid   = 0;
+			skirmish->lock_pid   = 0;
+			skirmish->lock_count = 0;
+
+			wake_up_interruptible_all(&skirmish->entry.wait);
+		  }
 		}
 
 		up(&skirmish->entry.lock);
@@ -713,7 +774,9 @@ void fusion_skirmish_reclaim_all(FusionDev * dev, int from_pid)
 
 		down(&skirmish->entry.lock);
 
-		if (skirmish->transfer_from_pid == from_pid) {
+		if (    (skirmish->transfer2_to == 0)
+		     &&  skirmish->transfer_to
+		     && (skirmish->transfer_from_pid == from_pid) ) {
 			FUSION_ASSERT(skirmish->transfer_to != 0);
 			FUSION_ASSERT(skirmish->transfer_from != 0);
 			FUSION_ASSERT(skirmish->transfer_count > 0);
@@ -727,6 +790,21 @@ void fusion_skirmish_reclaim_all(FusionDev * dev, int from_pid)
 			skirmish->transfer_from     = 0;
 			skirmish->transfer_from_pid = 0;
 			skirmish->transfer_count    = 0;
+		} else if (     skirmish->transfer2_to
+			    && (skirmish->transfer2_from_pid == from_pid) ) {
+			FUSION_ASSERT(skirmish->transfer2_to != 0);
+			FUSION_ASSERT(skirmish->transfer2_from != 0);
+			FUSION_ASSERT(skirmish->transfer2_count > 0);
+			FUSION_ASSUME(skirmish->lock_pid == 0);
+
+			skirmish->lock_fid   = skirmish->transfer2_from;
+			skirmish->lock_pid   = skirmish->transfer2_from_pid;
+			skirmish->lock_count = skirmish->transfer2_count;
+
+			skirmish->transfer2_to       = 0;
+			skirmish->transfer2_from     = 0;
+			skirmish->transfer2_from_pid = 0;
+			skirmish->transfer2_count    = 0;
 		}
 
 		up(&skirmish->entry.lock);
